import json
import numpy as np
from aiohttp import ClientError
from neo4j import GraphDatabase, Driver
from llm.embedding import get_embedding
# --- Neo4j è¿æ¥é…ç½® (è¯·æ›¿æ¢æˆæ‚¨çš„å®é™…é…ç½®) ---
URI = "bolt://localhost:7687"
USERNAME = "neo4j"
PASSWORD = "123456789"

# åˆå§‹åŒ–é©±åŠ¨
DRIVER = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))


def close_driver():
    """å…³é—­ Neo4j é©±åŠ¨è¿æ¥"""
    DRIVER.close()
    print("âœ… Neo4j driver closed.")


# --- æ¨¡æ‹Ÿ LLM æŠ½å–å‡ºçš„æ ‡å‡†åŒ– JSON çŸ¥è¯†å— (æ•°æ®ä¸å˜) ---
MOCK_LLM_OUTPUT_JSON = {
    "vulnerability_type": "Reentrancy",
    "severity": "High",
    "report_id": "Audit-R1-001",
    "snippet": "function withdraw(uint amount) public { \n    require(balances[msg.sender] >= amount);\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success);\n    balances[msg.sender] -= amount;\n}",
    "project_name": "Defi_Protocol_V1",
    "root_cause_analysis": {
        "logic_flow": [
            "Read state variable (balance)",
            "External call (msg.sender.call)",
            "Update state variable (balance)"
        ],
        "violated_invariant": "Checks-Effects-Interactions Pattern"
    },
    "code_pattern_abstract": "State update occurs physically after an external call to an untrusted address within the same control flow.",
    "impact": "Theft of all contract funds via recursive calls.",
    "remediation_suggestion": {
        "technique": "Check-Effects-Interactions / ReentrancyGuard",
        "code_change": "Move the balance update to happen before the external call, or add a nonReentrant modifier."
    },
    "false_positive_indicators": "If the external call has a fixed gas limit (transfer/send) or if a mutex lock (ReentrancyGuard) is present, this pattern is safe."
}


def write_knowledge_transaction(tx, knowledge_json: dict):
    """
    Neo4j äº‹åŠ¡å‡½æ•°ï¼šå°† LLM æŠ½å–çš„ç»“æ„åŒ–çŸ¥è¯†å†™å…¥å›¾è°±ã€‚
    ä½¿ç”¨ MERGE å®ç°å®ä½“å¯¹é½ã€‚
    """

    # æå–æ ¸å¿ƒæ•°æ®
    vt_name = knowledge_json["vulnerability_type"]
    cp_abstract = knowledge_json["code_pattern_abstract"]
    rc_analysis = knowledge_json["root_cause_analysis"]
    remediation = knowledge_json["remediation_suggestion"]

    # Cypher æŸ¥è¯¢ï¼šä½¿ç”¨ MERGE å®ç°å®ä½“å¯¹é½å’Œå…³ç³»æ„å»º
    cypher_query = """
    // 1. Project èŠ‚ç‚¹
    MERGE (p:Project {name: $project_name})

    // 2. Finding èŠ‚ç‚¹ (ä¸»æ¡ˆä¾‹)
    CREATE (f:Finding {
        report_id: $report_id,
        severity: $severity,
        snippet: $snippet,
        timestamp: datetime()
    })

    // 3. VulnerabilityType èŠ‚ç‚¹ (å®ä½“å¯¹é½)
    MERGE (vt:VulnerabilityType {name: $vt_name})

    // 4. CodePattern èŠ‚ç‚¹ (å®ä½“å¯¹é½)
    MERGE (cp:CodePattern {
        pattern_abstract: $cp_abstract,
        false_positive_indicators: $false_positive_indicators
    })

    // 5. RootCause èŠ‚ç‚¹ (å®ä½“å¯¹é½)
    MERGE (rc:RootCause {
        violated_invariant: $violated_invariant,
        logic_flow: $logic_flow
    })

    // 6. Remediation èŠ‚ç‚¹ (å®ä½“å¯¹é½)
    MERGE (rem:Remediation {
        technique: $rem_technique,
        code_change: $rem_code_change
    })

    // --- åˆ›å»ºå…³ç³» (Relationships) ---
    MERGE (f)-[:AUDITED_IN]->(p)
    MERGE (f)-[:IS_TYPE_OF]->(vt)
    MERGE (f)-[:CAUSED_BY]->(cp)
    MERGE (f)-[:FIXED_BY]->(rem)
    MERGE (vt)-[:HAS_ROOT_CAUSE]->(rc)

    RETURN f.report_id
    """

    # å‡†å¤‡å‚æ•°
    params = {
        "project_name": knowledge_json["project_name"],
        "report_id": knowledge_json["report_id"],
        "severity": knowledge_json["severity"],
        "snippet": knowledge_json["snippet"],
        "vt_name": vt_name,
        "cp_abstract": cp_abstract,
        "false_positive_indicators": knowledge_json["false_positive_indicators"],
        "violated_invariant": rc_analysis["violated_invariant"],
        "logic_flow": rc_analysis["logic_flow"],
        "rem_technique": remediation["technique"],
        "rem_code_change": remediation["code_change"],
    }

    tx.run(cypher_query, params)


def write_knowledge_to_graph(driver: Driver, knowledge_json: dict):
    """ä¸»å†™å…¥å‡½æ•°ï¼šç®¡ç†äº‹åŠ¡ (ä½¿ç”¨ execute_write)"""
    try:
        with driver.session() as session:
            session.execute_write(write_knowledge_transaction, knowledge_json)
        print(f"âœ… Knowledge for Finding ID '{knowledge_json['report_id']}' successfully written to Neo4j.")
    except ClientError as e:
        print(f"âŒ Failed to write knowledge due to Neo4j Client Error: {e}")
    except Exception as e:
        print(f"âŒ Failed to write knowledge to Neo4j: {e}")


# ----------------------------------------------------------------------
# 4. æ¨¡æ‹Ÿå‘é‡åŒ–ä¸ç´¢å¼•å…³è” (ä½¿ç”¨æ–°çš„é©±åŠ¨è¿›è¡Œæ›´æ–°)
# ----------------------------------------------------------------------

def mock_vector_generation(text: str) -> list[float]:
    return get_embedding(text)[0]

def associate_vector_transaction(tx, report_id: str, vector: list[float], node_id_query: str):
    """
    Neo4j äº‹åŠ¡å‡½æ•°ï¼šå°†å‘é‡å±æ€§æ·»åŠ åˆ° Finding èŠ‚ç‚¹ã€‚
    """
    # 1. è®¾ç½®å‘é‡å±æ€§
    tx.run(
        """
        MATCH (f:Finding {report_id: $report_id})
        SET f.snippet_vector = $vector
        """,
        report_id=report_id,
        vector=vector
    )

    # 2. è·å– Neo4j å†…éƒ¨ ID (ç”¨äºæ¨¡æ‹Ÿå‘é‡æ•°æ®åº“å…³è”é”®)
    result = tx.run(node_id_query).single()
    return result[0] if result else None


def associate_vector_to_finding(driver: Driver, report_id: str, snippet: str):
    snippet_vector = mock_vector_generation(snippet)
    node_id_query = f"MATCH (f:Finding {{report_id: '{report_id}'}}) RETURN ID(f) AS node_id"

    try:
        with driver.session() as session:
            # ğŸš€ ä¿®å¤ç‚¹ï¼šæ›¿æ¢ä¸º execute_write()
            node_id = session.execute_write(
                associate_vector_transaction,
                report_id,
                snippet_vector,
                node_id_query
            )

        print(f"\nâœ… Vectorization Simulated and Neo4j Updated:")
        print(f"   - Finding ID: {report_id}")
        print(f"   - Neo4j Node ID: {node_id} (ç”¨äºå‘é‡æ•°æ®åº“ç´¢å¼•å…³è”)")
        print(f"   - Vector Dimension: {len(snippet_vector)}")
        print(f"   - Vector (partial): {snippet_vector[:5]}...")

    except ClientError as e:
        print(f"âŒ Failed to associate vector due to Neo4j Client Error: {e}")
    except Exception as e:
        print(f"âŒ Failed to associate vector: {e}")

# ----------------------------------------------------------------------
# --- æ‰§è¡Œæ•´ä¸ªé˜¶æ®µä¸‰æµç¨‹ ---
# ----------------------------------------------------------------------

try:
    # éªŒè¯é©±åŠ¨è¿æ¥
    with DRIVER.session() as session:
        session.run("RETURN 1").single()
        print("âœ… Successfully connected to Neo4j using GraphDatabase.driver.")

    # 1. å†™å…¥ç»“æ„åŒ–çŸ¥è¯†
    write_knowledge_to_graph(DRIVER, MOCK_LLM_OUTPUT_JSON)

    # 2. å†™å…¥å‘é‡åŒ–æ•°æ®
    associate_vector_to_finding(
        DRIVER,
        MOCK_LLM_OUTPUT_JSON["report_id"],
        MOCK_LLM_OUTPUT_JSON["snippet"]
    )

finally:
    # æµç¨‹ç»“æŸï¼Œå…³é—­é©±åŠ¨
    close_driver()