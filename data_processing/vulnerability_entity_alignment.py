import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from neo4j import GraphDatabase
import json
from datetime import datetime
import uuid
from llm.embedding import get_embedding

# --- 0. NEO4J 配置 ---
URI = "neo4j://localhost:7687"
USERNAME = "neo4j"
PASSWORD = "123456789"
DRIVER = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))

# --- 1. 模拟数据和配置 ---
SIMILARITY_THRESHOLD = 0.70
VECTOR_DIMENSION = 768  # 模拟向量维度 (实际中可能是 768 或 1536)

# 模拟 LLM 提取的新知识块 (代表一个 Finding)
new_finding_data = {
    "vulnerability_type": "Reentrant",  # <--- 需要向量化和对齐的新实体名
    "severity": "High",
    "root_cause_analysis": {
        "logic_flow": [
            "Read state variable (balance)",
            "External call (msg.sender.call)",
            "Update state variable (balance)"
        ],
        "violated_invariant": "Checks-Effects-Interactions Pattern"
    },
    "code_pattern_abstract": "State update occurs physically after an external call to an untrusted address within the same control flow.",
    "impact": "Theft of all contract funds via recursive calls.",
    "remediation_suggestion": {
        "technique": "Check-Effects-Interactions / ReentrancyGuard",
        "code_change": "Move the balance update to happen before the external call, or add a nonReentrant modifier."
    },
    "false_positive_indicators": "If the external call has a fixed gas limit (transfer/send) or if a mutex lock (ReentrancyGuard) is present, this pattern is safe."
}


# --- 2. 向量化 (步骤 2) ---

def get_query_vector(entity_name: str) -> list:
    """
    获取实体的向量表示

    Args:
        entity_name: 实体名称

    Returns:
        向量列表

    Raises:
        ValueError: 当返回的向量维度不匹配时
    """
    embedding_list = get_embedding([entity_name])
    if embedding_list and embedding_list[0]:
        if len(embedding_list[0]) != VECTOR_DIMENSION:
            raise ValueError(
                f"get_embedding 实际返回维度 {len(embedding_list[0])} 与期望维度 {VECTOR_DIMENSION} 不一致。")
        return embedding_list[0]
    return embedding_list


# --- 3. 实体向量化与相似度查询 (步骤 1 & 3) ---

def get_standard_entities_and_vector(tx):
    """
    步骤 1: 从 Neo4j 获取所有标准实体 (VulnerabilityType) 及其向量。

    Args:
        tx: Neo4j 事务对象

    Returns:
        标准实体列表,每个包含 id, name, vector
    """
    result = tx.run("""
        MATCH (v:VulnerabilityType)
        WHERE v.embedding IS NOT NULL
        RETURN ID(v) AS id, v.name AS name, v.embedding AS vector
    """)
    entities = []
    for record in result:
        entities.append({
            "id": record["id"],
            "name": record["name"],
            "vector": np.array(record["vector"])
        })
    return entities


def knn_search(query_vector: list, standard_entities: list) -> dict or None:
    """
    步骤 3: 向量相似度查询 (k-NN Search)
    在实际使用 Neo4j GDS 时,您会使用 db.index.vector.queryNodes。
    这里使用 sklearn 模拟查询逻辑。

    Args:
        query_vector: 查询向量
        standard_entities: 标准实体列表

    Returns:
        最相似的实体字典或 None
    """
    if not standard_entities:
        return None

    entity_vectors = np.array([e['vector'] for e in standard_entities])
    query_vector_np = np.array(query_vector).reshape(1, -1)

    similarities = cosine_similarity(query_vector_np, entity_vectors)[0]

    # 组合结果并排序
    results = []
    for i, sim in enumerate(similarities):
        results.append({
            "name": standard_entities[i]["name"],
            "id": standard_entities[i]["id"],
            "similarity": sim
        })

    results.sort(key=lambda x: x['similarity'], reverse=True)
    return results[0]  # 返回 Top 1


# --- 4. 核心执行函数 (步骤 4 & 5) ---

def process_entity_alignment_and_ingestion(tx, new_data: dict, V_query: list) -> dict:
    """
    执行整个实体对齐和知识写入图谱的事务。

    Args:
        tx: Neo4j 事务对象
        new_data: 新的 Finding 数据
        V_query: 查询向量

    Returns:
        dict: 对齐结果,包含:
            - aligned_entity_name: 对齐后的标准实体名称
            - action: 执行的动作 (MAP_TO_EXISTING 或 CREATE_NEW_STANDARD)
            - similarity: 相似度分数 (如果是映射)
            - entity_id: 实体ID
            - original_name: 原始实体名称
    """
    new_entity_name = new_data['vulnerability_type']

    # 1. 获取现有标准实体及其向量 (步骤 1)
    standard_entities = get_standard_entities_and_vector(tx)

    # 2. k-NN 查询 (步骤 3)
    E_best = knn_search(V_query, standard_entities)
    if E_best:
        print(f"  -> 搜索结果: {E_best}")

    # 3. 判断与映射逻辑 (步骤 4)
    alignment_result = {
        "original_name": new_entity_name,
        "aligned_entity_name": None,
        "action": None,
        "similarity": None,
        "entity_id": None
    }

    if not standard_entities:
        action = "CREATE_NEW_STANDARD"
        standard_entity_id = "NEW"
        alignment_result["action"] = action
        alignment_result["aligned_entity_name"] = new_entity_name
        print(f"  -> Cold Start: '{new_entity_name}' 将作为图谱中的第一个标准实体。")

    elif E_best and E_best['similarity'] >= SIMILARITY_THRESHOLD:
        action = "MAP_TO_EXISTING"
        standard_entity_id = E_best['id']
        alignment_result["action"] = action
        alignment_result["aligned_entity_name"] = E_best['name']
        alignment_result["similarity"] = float(E_best['similarity'])
        alignment_result["entity_id"] = standard_entity_id
        print(f"  -> 匹配成功 (得分: {E_best['similarity']:.3f}): 映射到 '{E_best['name']}' (ID: {standard_entity_id})")

    else:
        action = "CREATE_NEW_STANDARD"
        standard_entity_id = "NEW"
        alignment_result["action"] = action
        alignment_result["aligned_entity_name"] = new_entity_name
        alignment_result["similarity"] = float(E_best['similarity']) if E_best else None
        print(f"  -> 新类型 (得分: {E_best['similarity']:.3f}): 创建新的 VulnerabilityType 节点。")

    # 4. 写入图谱 (步骤 5) - 使用参数化查询

    # 构造辅助实体的属性
    finding_id = str(uuid.uuid4())

    # 将复杂的 JSON 属性序列化为字符串,方便传入 Cypher
    root_cause_props = json.dumps(new_data['root_cause_analysis'])
    remediation_props = json.dumps(new_data['remediation_suggestion'])
    cypher_params = {
        "finding_id": finding_id,
        "new_entity_name": new_entity_name,
        "severity": new_data['severity'],
        "abstract": new_data['code_pattern_abstract'],
        "false_positive": new_data['false_positive_indicators'],
        "root_cause": root_cause_props,
        "remediation": remediation_props,
        "v_query": V_query
    }

    if action == "MAP_TO_EXISTING":
        query = f"""
        MATCH (vt:VulnerabilityType)
        WHERE ID(vt) = {standard_entity_id}

        CREATE (rc:RootCause) SET rc = apoc.convert.fromJsonMap($root_cause)
        CREATE (cp:CodePattern {{pattern_abstract: $abstract, false_positive_indicators: $false_positive}})
        CREATE (rm:Remediation) SET rm = apoc.convert.fromJsonMap($remediation)

        CREATE (f:Finding {{report_id: $finding_id, extracted_name: $new_entity_name, severity: $severity}})

        CREATE (f)-[:IS_TYPE_OF]->(vt)
        CREATE (f)-[:CAUSED_BY]->(cp)
        CREATE (f)-[:FIXED_BY]->(rm)
        CREATE (vt)-[:HAS_ROOT_CAUSE]->(rc) 

        RETURN vt, f
        """

    else:  # 场景 A/C: 创建新的标准实体节点
        query = f"""
        // 创建新的标准实体节点 (VulnerabilityType)
        CREATE (vt:VulnerabilityType {{
          name: $new_entity_name,
          embedding: $v_query,
          created_at: datetime()
        }})

        // 创建辅助实体
        CREATE (rc:RootCause) SET rc = apoc.convert.fromJsonMap($root_cause)
        CREATE (cp:CodePattern {{pattern_abstract: $abstract, false_positive_indicators: $false_positive}})
        CREATE (rm:Remediation) SET rm = apoc.convert.fromJsonMap($remediation)

        // 创建 Finding
        CREATE (f:Finding {{report_id: $finding_id, extracted_name: $new_entity_name, severity: $severity}})

        // 连接关系
        CREATE (f)-[:IS_TYPE_OF]->(vt)
        CREATE (f)-[:CAUSED_BY]->(cp)
        CREATE (f)-[:FIXED_BY]->(rm)
        CREATE (vt)-[:HAS_ROOT_CAUSE]->(rc) 

        RETURN vt, f
        """

    result = tx.run(query, cypher_params)
    record = result.single()

    if record and action == "CREATE_NEW_STANDARD":
        # 获取新创建的实体ID
        alignment_result["entity_id"] = record["vt"].id

    print("  -> 写入图谱事务已提交。")

    return alignment_result


# --- 5. 主执行函数 ---

def align_and_ingest_entity(new_data: dict) -> dict:
    """
    执行实体对齐和知识图谱写入的完整流程

    Args:
        new_data: 新的 Finding 数据字典

    Returns:
        dict: 对齐结果,包含:
            - aligned_entity_name: 对齐后的标准实体名称
            - action: 执行的动作
            - similarity: 相似度分数 (如果适用)
            - entity_id: 实体ID
            - original_name: 原始实体名称

    Raises:
        Exception: 执行过程中的任何错误
    """
    entity_name = new_data['vulnerability_type']
    print(f"开始处理实体: '{entity_name}'")

    try:
        # 1. 向量化
        print("步骤 1: 生成查询向量...")
        V_query = get_query_vector(entity_name)

        # 2. 执行实体对齐和写入
        print("步骤 2: 执行实体对齐和图谱写入...")
        with DRIVER.session() as session:
            result = session.execute_write(
                process_entity_alignment_and_ingestion,
                new_data,
                V_query
            )

        print(f"\n✓ 实体对齐完成!")
        print(f"  原始名称: {result['original_name']}")
        print(f"  对齐名称: {result['aligned_entity_name']}")
        print(f"  动作: {result['action']}")
        if result['similarity'] is not None:
            print(f"  相似度: {result['similarity']:.3f}")

        return result

    except Exception as e:
        print(f"\n✗ 实体对齐失败: {str(e)}")
        raise


# --- 6. 使用示例 ---

if __name__ == "__main__":
    try:
        # 执行实体对齐
        alignment_result = align_and_ingest_entity(new_finding_data)

        # 使用对齐后的实体名称
        print(f"\n可以使用对齐后的实体名称: {alignment_result['aligned_entity_name']}")

    except Exception as e:
        print(f"程序执行出错: {e}")
    finally:
        DRIVER.close()