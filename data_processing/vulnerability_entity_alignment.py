import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from neo4j import GraphDatabase
import json
from datetime import datetime
import uuid
from llm.embedding import get_embedding
# --- 0. NEO4J 配置 ---
URI = "neo4j://localhost:7687"
USERNAME = "neo4j"
PASSWORD = "123456789"
DRIVER = GraphDatabase.driver(URI, auth=(USERNAME, PASSWORD))

# --- 1. 模拟数据和配置 ---
SIMILARITY_THRESHOLD = 0.70
VECTOR_DIMENSION = 768  # 模拟向量维度 (实际中可能是 768 或 1536)

# 模拟 LLM 提取的新知识块 (代表一个 Finding)
new_finding_data = {
    "vulnerability_type": "Reentrant",  # <--- 需要向量化和对齐的新实体名
    "severity": "High",
    "root_cause_analysis": {
        "logic_flow": [
            "Read state variable (balance)",
            "External call (msg.sender.call)",
            "Update state variable (balance)"
        ],
        "violated_invariant": "Checks-Effects-Interactions Pattern"
    },
    "code_pattern_abstract": "State update occurs physically after an external call to an untrusted address within the same control flow.",
    "impact": "Theft of all contract funds via recursive calls.",
    "remediation_suggestion": {
        "technique": "Check-Effects-Interactions / ReentrancyGuard",
        "code_change": "Move the balance update to happen before the external call, or add a nonReentrant modifier."
    },
    "false_positive_indicators": "If the external call has a fixed gas limit (transfer/send) or if a mutex lock (ReentrancyGuard) is present, this pattern is safe."
}


# --- 2. 向量化 (步骤 2) ---

def get_query_vector(entity_name: str) -> list:
    embedding_list = get_embedding([entity_name])
    if embedding_list and embedding_list[0]:
        # 可以添加一个断言来检查维度是否正确返回
        if len(embedding_list[0]) != VECTOR_DIMENSION:
            raise ValueError(
                f"get_embedding 实际返回维度 {len(embedding_list[0])} 与期望维度 {VECTOR_DIMENSION} 不一致。")
        return embedding_list[0]
    return embedding_list

# --- 3. 实体向量化与相似度查询 (步骤 1 & 3) ---

def get_standard_entities_and_vector(tx):
    """
    步骤 1: 从 Neo4j 获取所有标准实体 (VulnerabilityType) 及其向量。
    """
    result = tx.run("""
        MATCH (v:VulnerabilityType)
        WHERE v.embedding IS NOT NULL
        RETURN ID(v) AS id, v.name AS name, v.embedding AS vector
    """)
    entities = []
    for record in result:
        entities.append({
            "id": record["id"],
            "name": record["name"],
            "vector": np.array(record["vector"])
        })
    return entities


def knn_search(query_vector: list, standard_entities: list) -> dict or None:
    """
    步骤 3: 向量相似度查询 (k-NN Search)
    在实际使用 Neo4j GDS 时，您会使用 db.index.vector.queryNodes。
    这里使用 sklearn 模拟查询逻辑。
    """
    if not standard_entities:
        return None

    entity_vectors = np.array([e['vector'] for e in standard_entities])
    query_vector_np = np.array(query_vector).reshape(1, -1)

    similarities = cosine_similarity(query_vector_np, entity_vectors)[0]

    # 组合结果并排序
    results = []
    for i, sim in enumerate(similarities):
        results.append({
            "name": standard_entities[i]["name"],
            "id": standard_entities[i]["id"],
            "similarity": sim
        })

    results.sort(key=lambda x: x['similarity'], reverse=True)
    return results[0]  # 返回 Top 1


# --- 4. 核心执行函数 (步骤 4 & 5) ---

def process_entity_alignment_and_ingestion(tx, new_data: dict, V_query: list):
    """
    执行整个实体对齐和知识写入图谱的事务。
    """
    new_entity_name = new_data['vulnerability_type']

    # 1. 获取现有标准实体及其向量 (步骤 1)
    standard_entities = get_standard_entities_and_vector(tx)

    # 2. k-NN 查询 (步骤 3)
    E_best = knn_search(V_query, standard_entities)
    print(f"  -> 搜索结果: {E_best}")
    # 3. 判断与映射逻辑 (步骤 4)
    if not standard_entities:
        action = "CREATE_NEW_STANDARD"
        standard_entity_id = "NEW"
        print(f"  -> Cold Start: '{new_entity_name}' 将作为图谱中的第一个标准实体。")
    elif E_best and E_best['similarity'] >= SIMILARITY_THRESHOLD:
        action = "MAP_TO_EXISTING"
        standard_entity_id = E_best['id']
        print(f"  -> 匹配成功 (得分: {E_best['similarity']:.3f}): 映射到 '{E_best['name']}' (ID: {standard_entity_id})")
    else:
        action = "CREATE_NEW_STANDARD"
        standard_entity_id = "NEW"
        print(f"  -> 新类型 (得分: {E_best['similarity']:.3f}): 创建新的 VulnerabilityType 节点。")

    # 4. 写入图谱 (步骤 5) - 使用参数化查询

    # 构造辅助实体的属性
    finding_id = str(uuid.uuid4())
    timestamp = datetime.now().isoformat()

    # 将复杂的 JSON 属性序列化为字符串，方便传入 Cypher
    root_cause_props = json.dumps(new_data['root_cause_analysis'])
    remediation_props = json.dumps(new_data['remediation_suggestion'])
    cypher_params = {
        "finding_id": finding_id,
        "new_entity_name": new_entity_name,
        "severity": new_data['severity'],
        "abstract": new_data['code_pattern_abstract'],
        "false_positive": new_data['false_positive_indicators'],
        "root_cause": root_cause_props,
        "remediation": remediation_props,
        "v_query": V_query
    }

    if action == "MAP_TO_EXISTING":
        query = f"""
        MATCH (vt:VulnerabilityType)
        WHERE ID(vt) = {standard_entity_id}

        CREATE (rc:RootCause) SET rc = apoc.convert.fromJsonMap($root_cause)
        CREATE (cp:CodePattern {{pattern_abstract: $abstract, false_positive_indicators: $false_positive}})
        CREATE (rm:Remediation) SET rm = apoc.convert.fromJsonMap($remediation)

        CREATE (f:Finding {{report_id: $finding_id, extracted_name: $new_entity_name, severity: $severity}})

        CREATE (f)-[:IS_TYPE_OF]->(vt)
        CREATE (f)-[:CAUSED_BY]->(cp)
        CREATE (f)-[:FIXED_BY]->(rm)
        CREATE (vt)-[:HAS_ROOT_CAUSE]->(rc) 

        RETURN vt, f
        """

    else:  # 场景 A/C: 创建新的标准实体节点
        query = f"""
        // 创建新的标准实体节点 (VulnerabilityType)
        CREATE (vt:VulnerabilityType {{
          name: $new_entity_name,
          embedding: $v_query,
          created_at: datetime()
        }})

        // 创建辅助实体
        CREATE (rc:RootCause) SET rc = apoc.convert.fromJsonMap($root_cause)
        CREATE (cp:CodePattern {{pattern_abstract: $abstract, false_positive_indicators: $false_positive}})
        CREATE (rm:Remediation) SET rm = apoc.convert.fromJsonMap($remediation)

        // 创建 Finding
        CREATE (f:Finding {{report_id: $finding_id, extracted_name: $new_entity_name, severity: $severity}})

        // 连接关系
        CREATE (f)-[:IS_TYPE_OF]->(vt)
        CREATE (f)-[:CAUSED_BY]->(cp)
        CREATE (f)-[:FIXED_BY]->(rm)
        CREATE (vt)-[:HAS_ROOT_CAUSE]->(rc) 

        RETURN vt, f
        """

    tx.run(query, cypher_params)
    print("  -> 写入图谱事务已提交。")


# --- 5. 运行主逻辑 ---

if __name__ == "__main__":

    print("--- 实体对齐与知识图谱写入 ---")
    try:
        # Step 2: 新实体向量化
        new_entity_name = new_finding_data['vulnerability_type']
        V_query = get_query_vector(new_entity_name)
        print(f"\n✨ 步骤 2: 新实体 '{new_entity_name}' 已向量化 ({len(V_query)} 维).")

        with DRIVER.session() as session:
            # Step 1 & 3: 在事务中运行查询和写入
            session.execute_write(process_entity_alignment_and_ingestion, new_finding_data, V_query)

    except Exception as e:
        print(f"\n❌ 发生错误：{e}")
        print("请检查 Neo4j 服务是否启动，以及 URI, USERNAME, PASSWORD 配置是否正确。")
    finally:
        DRIVER.close()
        print("\n--- 脚本执行完毕，Neo4j 连接已关闭 ---")